/*
 * tivodecode, (c) 2006, Jeremy Drake
 * See COPYING file for license terms
 */

#ifndef TURING_STREAM_H_
#define TURING_STREAM_H_

/*following copied from Turing.h, so we can avoid including it here */
#define MAXSTREAM   340 /* bytes, maximum stream generated by one call */

#if defined(HAVE_SIZE_T) && SIZEOF_SIZE_T == 8
typedef size_t td_uint64_t;
#define HAVE_TD_UINT64_T 1
#elif defined(HAVE_UNSIGNED_LONG) && SIZEOF_UNSIGNED_LONG == 8
typedef unsigned long td_uint64_t;
#define HAVE_TD_UINT64_T 1
#elif defined(HAVE_UNSIGNED_LONG_LONG) && SIZEOF_UNSIGNED_LONG_LONG == 8
typedef unsigned long long td_uint64_t;
#define HAVE_TD_UINT64_T 1
#else
typedef unsigned long td_uint64_t;
/* #undef HAVE_TD_UINT64_T */
#endif

typedef struct turing_state_stream
{
    unsigned int cipher_pos;
    unsigned int cipher_len;

    unsigned int block_id;
    uint8_t stream_id;

    struct turing_state_stream *next;

    Turing *internal;
    uint8_t cipher_data[MAXSTREAM + sizeof(td_uint64_t)];
} turing_state_stream;

class TuringState
{
    private:
        uint8_t turingkey[20];
        turing_state_stream *active;

    public:
        void setup_key(uint8_t *buffer, size_t buffer_length, char *mak);
        void setup_metadata_key(uint8_t *buffer, size_t buffer_length,
                                char *mak);
        void prepare_frame_helper(uint8_t stream_id, int block_id);
        void prepare_frame(uint8_t stream_id, int block_id);
        void decrypt_buffer(uint8_t *buffer, size_t buffer_length);
        void skip_data(size_t bytes_to_skip);
        void destruct();
        void dump();
};

#endif // TURING_STREAM_H_
